package ks.action.group{	import ks.action.*;	import ks.core.*;		/**	 * A group of actions that all start simultaneously when the group's 	 * start() method is called. This allows you to treat all the actions	 * within the group as a single unit.	 * 	 * @author Mims Wright	 * @since 0.1	 */	public class KSParallelGroup extends AbstractActionGroup	{					/**		 * Returns true when the group is running. 		 */		public  function get childrenAreRunning():Boolean { return _runningChildren > 0; }				/** 		 * The total duration for the parallel group will return		 * the duration and delay of the longest child action.		 */		override public function get totalDuration():int {			var longestChildDuration:int = 0;			for each (var child:IAction in childActions) {				var childDuration:int = child.delay + child.duration;				if (childDuration > longestChildDuration) {					longestChildDuration = childDuration;				}			}			return longestChildDuration;		}				/**		 * The number of children currently running.		 * This is used internally to figure when the group has 		 * finished running. 		 */		protected var _runningChildren:int = 0;				/**		 * Constructor.		 * 		 * @params children A list of actions that will be added as children of the group. 		 * 					If any of the children are arrays, they will be parsed into		 * 					KSSequenceGroups.  		 * 		 * @example <listing version="3.0">		 * var parallel:KSParallelGroup;		 * 		 * // new group with no children.		 * parallel = new KSParallelGroup();		 * 		 * // new group with 3 children. all three will execute simultaneously.		 * parallel = new KSParallelGroup( myAction, myAction2, myAction3);		 * 		 * // new group with styntactic sugar for creating a sequence on the fly. 		 * // All acitons will start simultaneously except for myAction3 will execute after 		 * // myAction2 completes. 		 * // this is identical to using:		 * // parallel = new KSParallelGroup( myAction, new KSSequenceGroup(myAction2, myAction3), myAction4);		 * parallel = new KSParallelGroup( 		 * 					mAction, 		 * 					[myAction2, myAction3], 		 * 					myAction4		 * 			  );		 * </listing>		 */		public function KSParallelGroup (... children) {			super();			var l:int = children.length;			for (var i:int = 0; i < l; i++) {				// adds the action using a special internal method that parses out arrays into groups.				addActionOrSequence(children[i]); 			}		}				/**		 * An internal function used by the constructor and by addActionOrParallel() that will		 * check the input for arrays and convert them to sequence groups.		 * 		 * Notice that the groups can be nested. If an array contains an array, that array will be		 * parsed into a parallel group by addActionOrParallel(). 		 * 		 * @see org.as3lib.kitchensync.action.group.KSSequenceGroup#KSSequenceGroup()		 * @see org.as3lib.kitchensync.action.group.KSSequenceGroup#addActionOrParallel()		 * 		 * @param addActionOrSequence Either an IAction or an array. Arrays will be added to the group 		 * 						   as a KSSequenceGroup. 		 * @private 		 */ 		internal function addActionOrSequence(actionOrSequnece:Object):void {			if (actionOrSequnece is IAction) {				addAction(IAction(actionOrSequnece));				return;			}			if (actionOrSequnece is Array) {				var sequence:KSSequenceGroup = new KSSequenceGroup();				for each (var item:Object in (actionOrSequnece as Array)) {					sequence.addActionOrParallel(item);				}				addAction(sequence);				return;			}		}				/**		 * When the first update occurs, all of the child actions are started simultaniously.		 */		override public function update(currentTime:int):void {			if (startTimeHasElapsed(currentTime) && !childrenAreRunning) {				// reset the number of running children.				_runningChildren = 0;								// for all child actions				var l:int = _childActions.length;				for (var i:int=0; i < l; i+=1) {					// add one running child.					_runningChildren++;										var childAction:IAction = IAction(_childActions[i]);					// add a listener to each action so that the completion of the entire group can be tracked.					childAction.addEventListener(KitchenSyncEvent.ACTION_START, onChildStart);					childAction.addEventListener(KitchenSyncEvent.ACTION_COMPLETE, onChildFinished);				}				for (i = 0; i < l; i+=1) {					childAction = IAction(_childActions[i]);					// start the child action					childAction.start();				}				// once this has started, it doesn't need updates anymore.				unregister();			}		}						/**		 * Called when child actions are completed. After each is finished, checks to see if the entire set is 		 * complete. If not, it waits for the next child.		 * Completed children are removed from the array so they can be garbage collected.		 * 		 * @param event - The SynchronizerEvent.COMPLETE		 * @param event - The SynchronizerEvent.CHILD_COMPLETE		 */		override protected function onChildFinished (event:KitchenSyncEvent):void {			super.onChildFinished(event);			var childAction:IAction = IAction(event.target);			childAction.removeEventListener(KitchenSyncEvent.ACTION_COMPLETE, onChildFinished);			childAction.removeEventListener(KitchenSyncEvent.ACTION_START, onChildStart);			_runningChildren--;			if (_runningChildren <= 0) {				complete();			}		}				/** @inheritDoc */		override public function stop():void {			super.stop();			_runningChildren = 0;		}				/** @inheritDoc */		override public function clone():IAction {			var clone:KSParallelGroup = new KSParallelGroup();			for (var i:int = 0; i < _childActions.length; i++) {				var action:IAction = getChildAtIndex(i).clone();				clone.addActionAtIndex(action, i);			}			clone.delay = _delay;			clone.autoDelete = _autoDelete;			return clone;		}				override public function toString():String {			return "KSParallelGroup [" + _childActions + "]";		}	}}